## 题目地址
https://leetcode-cn.com/problems/next-greater-element-i/

## 题目描述（简单）

给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。

nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。

```
输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释:
    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。
    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。
    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。


输入: nums1 = [2,4], nums2 = [1,2,3,4].
输出: [3,-1]
解释:
    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。
    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 

```

## 相关企业(从左到右，按频率排序)

## 关联题目


## 解法
### 方法一：递归

里面函数地目的就是寻找到下个节点，当寻找到了以后。就改变指向的关系，也就是让下一个节点指向自己，同时自己指向为空。

然后返回当前的节点。当前节点就是上一个递归函数想要获取的下一个节点，以此类推，就能反转。

这里我偷个懒，当递归到原来的尾节点时，我用self.tail来保存，这样返回的时候，就比较方便了。

* 时间复杂度 O(N)：假设 n 是列表的长度，那么时间复杂度为 O(n)。
* 空间复杂度 O(N)：假设 n 是列表的长度，那么时间复杂度为 O(n)。

### 方法二：迭代

在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！

* 时间复杂度 O(N)：假设 n 是列表的长度，那么时间复杂度为 O(n)。
* 空间复杂度 O(1)
